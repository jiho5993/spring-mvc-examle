## AOP(Aspect Oriented Programming)
AOP용어 자체를 한글로 바꾸면 측면 지향 프로그래밍이다.  
측면이 개발에서 의미하는 것은 비지니스 로직은 아니지만, 반드시 해야할 작업을 말한다.  
다시 쉽게 말하자면 정말 기능을 구현하는데 있어서 핵심적인 작업은 아니지만 반드시 해야되는 공통된 작업이라고 할 수 있다.  
이러한 것들을 횡단관심사(cross-concern)라고 한다.  
횡단관심사는 시스템의 곳곳에서 공통으로 사용되지만, 그 자체가 목적이 아니다. 다만 시스템의 완성도를 높여주는 역할을 해준다.  
예를 들면 보안 처리나 로그 기록, 트랜잭션과 같은 번거로운 작업들을 말한다.

## AOP와 OOP(Object Oriented Programming)
`AOP는 OOP를 대신하는 새로운 개념이 아니라, OOP를 더욱 OOP답게 사용할 수 있도록 도와주는 개념이다.`  
  
OOP는 객체를 재사용함으로써 반복되는 코드의 양을 굉장히 많이 줄일수가 있었지만 객체의 재사용에도 불구하고 반복되는 코드를 없앨수는 없었다.  
예를 들어 로그, 권한 체크, 인증, 예외 처리등 필수적으로 해야하기 때문에 소스에서 반복될 수 밖에 없는 부분이 존재했다.  
AOP는 이러한 부분을 해결해주었다. 기능을 비지니스 로직과 공통 모듈로 구분한 후에 개발자의 코드 밖에서 필요한 시점에 비지니스 로직에 삽입하여 실행되도록 한다.  
즉, OOP에서는 공통적인 기능을 각 객체의 횡단으로 입력했다면, AOP는 공통적인 기능을 종단간으로 삽일할 수 있도록 한 것이다.



## AOP와 관련된 용어
`외부 호출 --------------> Proxy 객체 -----> Target 객체`  

AOP의 구현은 Proxy패턴이라는 방식을 통해 이루어진다.
외부에서 특정한 객체를 호출하면, 실제 객체(Target)를 감싸고 있는 바깥쪽 객체(Proxy)를 통해 호출이 전달된다.  
Proxy객체는 AOP의 기능이 적용된 상태에서 호출을 받아 사용되고, 실제 객체와 동일한 타입을 자동으로 생성할 수 있기 때문에 외부에서는 실제 객체와 동일한 타입으로 호출할 수 있다.  

AOP를 이해하기 위해서는 아래의 용어의 이해가 필수적이다.
* `Aspect` : 공통 관심사에 대한 추상적인 명칭, 예를 들어 로깅이나 보안, 트랜잭션과 같은 기능 자체에 대한 용어
* `Advice` : 실제로 기능을 구현한 객체
* `Join Points` : 공통 관심사를 적용할 수 있는 대상, Spring AOP에서는 각 객체의 메서드가 해당됨
* `Pointcuts` : 여러 메서드 중 실제 Advice가 적용될 메서드
* `Target` : 대상 메서드가 가지는 객체
* `Proxy` :  Advice가 적용되었을 대 만들어지는 객체
* `Introduction` : Target에는 없는 새로운 메서드나 인스턴스 변수를 추가하는 기능
* `Weaving` : Advice나 Targetdl 결합되어서 프록시 객체를 만드는 과정

좀더 자세한 설명이 필요한 용어는 아래와 같다.
* **Advice** : 실제로 적용시키고 싶은 코드 자체를 의미한다.
개발자가 만드는 것은 Aspect가 아닌 클래스를 제작하고 `@Advice`에너테이션을 적용하는 것이다.
예를 들면 로그 출력기능, 파라미터 체크 기능 자체는 Aspect라는 용어로 부르지만 실제 구현 시에는 Advice를 제작한다고 표현한다.
* **Target** : 실제 비지니스 로직을 수행하는 객체를 의미한다. Aspect를 적용해야하는 대상 객체를 의미한다.
* **Join Points** : 작성된 Advice가 작동되는 위치를 의미한다.
예를 들면 `ArticleService`의 등록, 수정, 삭제만을 골라서 Advice를 적용할 수 있는데 이 때 `ArticleService`의 모든 메서드는 JoinPoint가 된다.
* **Pointcuts** : 여러 Join Points 중에서 Advice를 적용할 대상을 선택하는 정보를 의미한다. 이를 통해 특정 메서드는 Advice가 적용된 형태로 동작하게 된다.
    
## 마무리
AOP의 가장 큰 특징이자 장점은 중복되는 코드 제거, 효율적인 유지보수, 높은 생산성, 재활용성의 극대화, 변화수용의 용이성이 크다.  
개발자는 핵심로직에 보다 더 집중할 수 있도록, 부가 로직으로부터 자유롭게 해준다.

출처 : https://doublesprogramming.tistory.com/115